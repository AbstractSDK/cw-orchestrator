<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cw-orchestrator documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick-start</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/interfaces.html"><strong aria-hidden="true">3.1.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="tutorial/env-variable.html"><strong aria-hidden="true">3.2.</strong> Environment Vars</a></li><li class="chapter-item expanded "><a href="tutorial/scripting.html"><strong aria-hidden="true">3.3.</strong> Scripting</a></li><li class="chapter-item expanded "><a href="tutorial/integration-tests.html"><strong aria-hidden="true">3.4.</strong> Integration Tests</a></li><li class="chapter-item expanded "><a href="tutorial/integration.html"><strong aria-hidden="true">3.5.</strong> Product Integrations</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">4.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/ci-cd.html"><strong aria-hidden="true">4.1.</strong> CI/CD</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">5.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">6.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cw-orchestrator documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cw-orchestrator"><a class="header" href="#cw-orchestrator">cw-orchestrator</a></h1>
<p>cw-orchestrator is a testing and deployment tool for CosmWasm smart-contracts. It features execute and query endpoint function generation, network-agnostic transaction execution and a mock environment wrapper for complex multi-contract testing scenarios.</p>
<p>These docs contain a quick-start and a longer from tutorial-style walkthrough.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cw-orchestrator-quick-start-guide"><a class="header" href="#cw-orchestrator-quick-start-guide">Cw-Orchestrator Quick-Start Guide</a></h1>
<p>This guide will show you how to use the <code>cw-orchestrator</code> with your smart contract. Follow the steps below to add <code>cw-orch</code> to your contract's TOML file, enable the interface feature, add the interface macro to your contract's endpoints, and use interaction helpers to simplify contract calls and queries.</p>
<p>The snippets in this document are backed by an actual contact which you can check out <a href="https://github.com/AbstractSDK/cw-orchestrator/tree/main/contracts/counter">here</a>.</p>
<h2 id="adding-cw-orch-to-your-contracts-toml-file"><a class="header" href="#adding-cw-orch-to-your-contracts-toml-file">Adding <code>cw-orch</code> to Your Contract's TOML File</a></h2>
<p>To use the <code>cw-orchestrator</code>, you need to add <code>cw-orch</code> to your contract's TOML file. Run the command below in your contract's directory:</p>
<pre><code class="language-shell">$ cargo add --optional cw-orch
&gt; Adding cw-orch v0.10.0 to optional dependencies.
</code></pre>
<p>Alternatively, you can add it manually in your <code>Cargo.toml</code> file as shown below:</p>
<pre><code class="language-toml">[dependencies]
cw-orch = {version = &quot;0.10.0&quot;, optional = true } # Latest version at time of writing
</code></pre>
<p>Now that we have added <code>cw-orch</code> as an optional dependency we will want to enable it through a feature. This ensures that the code added by <code>cw-orch</code> is not included in the wasm artifact of the contract. To do this add an <code>interface</code> feature to the <code>Cargo.toml</code> and enable <code>cw-orch</code> when it is enabled.</p>
<p>To do this include the following in the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
interface = [&quot;dep:cw-orch&quot;]
</code></pre>
<h2 id="adding-the-interface-macro-to-your-contracts-endpoints"><a class="header" href="#adding-the-interface-macro-to-your-contracts-endpoints">Adding the Interface Macro to Your Contract's Endpoints</a></h2>
<p>With the dependency set up, you can now add the <code>interface</code> macro to your contract's endpoints. This macro will generate an interface to your contract that you can use to interact with it. You can get started by adding the feature-flagged interface macro to the contract's endpoints as shown in the code snippet below:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">struct InstantiateMsg;
</span><span class="boring">struct ExecuteMsg;
</span>
// In `contract.rs`
#[cfg_attr(feature=&quot;interface&quot;, cw_orch::interface_entry_point)] // &lt;--- Add this line
pub fn instantiate(
   deps: DepsMut,
   env: Env,
   info: MessageInfo,
   msg: InstantiateMsg,
 -&gt; StdResult&lt;Response&gt; {
    // ...
    Ok(Response::new())
}

#[cfg_attr(feature=&quot;interface&quot;, cw_orch::interface_entry_point)] // &lt;--- Add this line
pub fn execute(
   deps: DepsMut,
   env: Env,
   info: MessageInfo,
   msg: ExecuteMsg,
 -&gt; StdResult&lt;Response&gt; {
    // ...
    Ok(Response::new())
}
// ... Do the same for the other entry points (query, migrate, reply, sudo)
<span class="boring">}</span></code></pre></pre>
<p>By adding these lines, we generate code whenever the <code>interface</code> macro is enabled. The code generates a contract interface, the name of which will be the PascalCase of the crate's name.</p>
<h2 id="example-of-using-cw-orchestrator"><a class="header" href="#example-of-using-cw-orchestrator">Example of Using Cw-Orchestrator</a></h2>
<p>The following example provides a clear understanding of how to use <code>cw-orchestrator</code> with a smart contract. Here, we have a contract with a <code>Cargo.toml</code> file like the following:</p>
<pre><code class="language-toml"># Cargo.toml
[package]
name = &quot;example-contract&quot;
# ...

[features]
# Features that are enabled by default
default = [&quot;export&quot;]
# Exports the WASM entry points, similar to the `library` feature
export = []
# Enables the contracts's interface
interface = [&quot;dep:cw-orch&quot;]

[dependencies]
cw-orch = {version = &quot;0.10.0&quot;, optional = true }
# ...
</code></pre>
<p>Then our contract looks something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">use cosmwasm_schema::{entry_point};
</span><span class="boring">struct InstantiateMsg;
</span><span class="boring">struct ExecuteMsg;
</span><span class="boring">struct QueryMsg;
</span><span class="boring">struct MigrateMsg;
</span>// contract.rs
#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // Instantiate contract
    Ok(Response::default())
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    match msg {
        // match statements
        _ =&gt; todo!()
    }
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    match msg {
        // match statements
        _ =&gt; todo!()
    }
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
    Ok(Response::default())
}
<span class="boring">}</span></code></pre></pre>
<p>The macros generate an <code>ExampleContract</code> struct that is now available in <code>contract.rs</code>.<br />
You can now create a test in <code>contract/tests</code> and start interacting with the contract as shown below:</p>
<!-- ```rust
use cosmwasm_schema::QueryResponses;
use cosmwasm_std::to_binary;
use cosmwasm_std::Binary;
use cosmwasm_std::Deps;
use cosmwasm_std::DepsMut;
use cosmwasm_std::MessageInfo;
use cosmwasm_std::Response;
use cosmwasm_std::StdError;
use cosmwasm_std::StdResult;
``` -->
<p>Now that we have the dependency set up you can add the <code>interface_entry_point</code> macro to your contract's endpoints. This macro will generate an interface to your contract that you will be able to use to interact with your contract. Get started by adding the feature-flagged interface macro to the contract's endpoints:</p>
<pre><code class="language-rust no_run noplayground">// in contract.rs
#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    let state = State {
        count: msg.count,
        owner: info.sender.clone(),
    };
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    STATE.save(deps.storage, &amp;state)?;

    Ok(Response::new()
        .add_attribute(&quot;method&quot;, &quot;instantiate&quot;)
        .add_attribute(&quot;owner&quot;, info.sender)
        .add_attribute(&quot;count&quot;, msg.count.to_string()))
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    match msg {
        ExecuteMsg::Increment {} =&gt; execute::increment(deps),
        ExecuteMsg::Reset { count } =&gt; execute::reset(deps, info, count),
    }
}

// ... Do the same for the other entry points (query, migrate, reply, sudo)</code></pre>
<p>By adding these lines we generate code whenever the <code>interface_entry_point</code> macro is enabled.
The code will generate a contract interface. The contract interface will be the PascalCase of the crate's name.</p>
<p>It's a good idea to re-expose the interface in the crate's root so that it is easy to import:</p>
<pre><code class="language-rust no_run noplayground">// in lib.rs
#[cfg(feature = &quot;interface&quot;)]
pub use crate::contract::CounterContract;</code></pre>
<blockquote>
<p>The name of the crate is defined in the <code>Cargo.toml</code> file of your contract.</p>
</blockquote>
<p>If we now create a test in <code>contract/tests</code> we can start interacting with it!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct InstantiateMsg {};
</span><span class="boring">enum ExecuteMsg {
</span><span class="boring">      Increment {}
</span><span class="boring">};
</span><span class="boring">enum QueryMsg {
</span><span class="boring">      Config {}
</span><span class="boring">};
</span><span class="boring">struct MigrateMsg {};
</span>// contract/tests/example.rs
<span class="boring">use cosmwasm_std::{Addr};
</span>use cw_orch::prelude::*;
// import the generated interface
use example_contract::contract::ExampleContract;
#[test]
fn example_test() {
    // init mock environment
    let sender = Addr::unchecked(&quot;sender&quot;);
    // Init the mock environment (cw-multi-test App)
    let mock = Mock::new(&amp;sender);
    // `new()` function is available to construct the contract interface
    let example_contract = ExampleContract::new(&quot;example_contract&quot;, mock);
    // Now we can start scripting!

    // Upload the contract to the mock
    example_contract.upload()?;

    // Instantiate the contract
    example_contract.instantiate(&amp;InstantiateMsg { }, None, None)?;

    // Execute the newly instantiated contract
    example_contract.execute(&amp;ExecuteMsg::Increment { }, None)?;

    // Query
    let resp: String = example_contract.query(&amp;QueryMsg::Config { })?;

    // Migrate
    example_contract.migrate(&amp;MigrateMsg { }, None)?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interaction-helpers"><a class="header" href="#interaction-helpers">Interaction helpers</a></h2>
<p>cw-orchestrator provides an additional macro to simplify contract calls and queries. The macro generates functions on the interface for each variant of the contract's ExecuteMsg and QueryMsg.</p>
<p>Enabling this functionality is very straight-forward. Find your <code>ExecuteMsg</code> and <code>QueryMsg</code> definitions and add the <code>ExecuteFns</code> and <code>QueryFns</code> derive macros to them like below:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_schema::QueryResponses;
use cw_orch::{ExecuteFns, QueryFns};

#[cfg_attr(feature = &quot;interface&quot;, derive(ExecuteFns))]
pub enum ExecuteMsg {
    Increment {},
    // ...
}

#[cfg_attr(feature = &quot;interface&quot;, derive(QueryFns))]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(String)]
    Config {}
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Any variant of the <code>ExecuteMsg</code> and <code>QueryMsg</code> that has a <code>#[derive(ExecuteFns)]</code> or <code>#[derive(QueryFns)]</code> will have a function generated on the interface through a trait. The function will have the same name as the variant and will take the same arguments as the variant.</p>
<p>You can access these functions by importing the generated traits form the message file. The generated traits are named <code>ExecuteMsgFns</code> and <code>QueryMsgFns</code>.</p>
<pre><code class="language-rust ignore">// Import the generated traits
<span class="boring">use cosmwasm_std::{Addr};
</span>use example_contract::msg::{ExecuteMsgFns, QueryMsgFns};
use cw_orch::prelude::*;

fn example_test() {
    // init mock environment
    let sender = Addr::unchecked(&quot;sender&quot;);
    // Init the mock environment (cw-multi-test App)
    let mock = Mock::new(&amp;sender);
    // `new()` function is available to construct the contract interface
    let example_contract = ExampleContract::new(&quot;example_contract&quot;, mock);

    // Upload the contract to the mock
    example_contract.upload()?;

    // Instantiate the contract
    example_contract.instantiate(&amp;InstantiateMsg { }, None, None)?;

    // Execute the increment endpoint
    example_contract.increment()?;

    // Query the config
    // Return type optional!
    let resp: QueryResponse = example_contract.config()?;
}
<span class="boring">example_test();</span></code></pre>
<blockquote>
<p>The function arguments are ordered alphabetically to prevent breaking changes when struct fields are moved.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>In order to use cw-orchestrator you need access to the entry point message types (<code>InstantiateMsg</code>,<code>ExecuteMsg</code>,...) of the contracts you want to interact with.</p>
<p>If you want to perform on-chain transaction you also need access to the gRPC endpoint of a node. These are most-often available on port 9090.</p>
<blockquote>
<p>If you're unsure as to what the gRPC endpoint of your chain is, check the <a href="https://cosmos.directory">Cosmos Directory</a> and there should be some listed. cw-orchestrator ships with a set of urls that should contain at least one working endpoint. Feel free to add urls to the list and PR them!</p>
</blockquote>
<p>The following sections detail setting up a library package for the contract interfaces and a binary package for executable scripts.</p>
<p>Following this example, the project's structure should eventually look like:</p>
<pre><code class="language-path">.
├── Cargo.toml
├── artifacts
│   └── my_contract.wasm (binary file)
├── my-contract
│   ├── Cargo.toml
│   └── src
│       ├── contract.rs (execute, instantiate, query, ...)
│       └── ..
├── packages
│   ├── my-project
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   │       └── my-contract.rs (msgs)
│   └── interfaces
│       ├── Cargo.toml
│       └── src
│            └── lib.rs
│            └── my-contract.rs (interface_entry_point)
└── scripts
    ├── .env
    ├── Cargo.toml
    └── src
        ├── deploy.rs
        └── test_my_contract.rs
</code></pre>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><strong><a href="tutorial/./interfaces.html">Interfaces</a></strong>
<ul>
<li>Define interfaces for your contracts.</li>
</ul>
</li>
<li><strong><a href="tutorial/./env-variable.html">Environment File</a></strong>
<ul>
<li>Configure your mnemonics and log settings.</li>
</ul>
</li>
<li><strong><a href="tutorial/./scripting.html">Scripting</a></strong>
<ul>
<li>Write runnable scripts with your interfaces.</li>
</ul>
</li>
<li><strong><a href="tutorial/./integration.html">Integration</a></strong>
<ul>
<li>Export a deployment of your application for use in integration testing.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>To get started with cw-orchestrator, create a new folder in your project's package directory and add it to the workspace members.</p>
<pre><code class="language-shell">cd packages
cargo init --lib interfaces
cd interfaces
</code></pre>
<p>Now add <a href="https://crates.io/crates/cw-orch">cw-orchestrator</a> to <code>Cargo.toml</code> along with the package that contains the contract's endpoint messages.</p>
<pre><code class="language-bash">cargo add cw-orch
cargo add log # optional for logging
cargo add anyhow # optional for simple error handling
cargo add --path ../my-project
</code></pre>
<pre><code class="language-toml">[dependencies]
cw-orch = &quot;0.10.0&quot; # latest version as of writing this article
my-project = { path = &quot;../my-project&quot;}
# ...other dependencies
</code></pre>
<h2 id="defining-contract-interfaces"><a class="header" href="#defining-contract-interfaces">Defining Contract Interfaces</a></h2>
<p>The contract interface is a struct that provides accessible methods to deploy and interact with an instance of your contract. Let's see how to use it.</p>
<p>First, create a new file in the src directory of the interfaces package, and add it to the library declaration</p>
<pre><code class="language-bash">touch src/my-contract.rs
echo 'pub mod my_contract;' &gt;&gt; src/lib.rs
</code></pre>
<p>In your new file, define a struct for your contract interface and provide the [<code>Instantiate</code>|<code>Execute</code>|<code>Query</code>|<code>Migrate</code>] messages to the <code>contract</code> macro, which will generate fully-typed instantiate, execute, query, and migrate methods for this struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cw_orch::*;
// We use pub here to be able to import those messages directly
// from the interfaces crate in the next steps (scripting, intergation tests...)
pub use my_project::my_contract::{InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg};

#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg)]
pub struct MyContract&lt;Chain&gt;;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><em>If your entry point messages have any generic arguments, pull them out into new types before passing them into the macro.</em></p>
</blockquote>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>Next, you'll want to define the constructor for the interface we just defined. In order to do so, first include the contract interface (<code>instantiate</code>, <code>execute</code> and <code>query</code> functions) in your package :</p>
<pre><code class="language-bash">cargo add --path ../../my-contract
</code></pre>
<p>The generic <code>&lt;Chain&gt;</code> argument allows you to write functions for your interface that will be executable in different environments.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;Chain: CwEnv&gt; MyContract&lt;Chain&gt; {
    /// Construct a new instance of MyContract
    /// * `contract_id` - what your contract should be called in local state (*not* on-chain)
    /// * `chain` - the environment to deploy to
    pub fn new(contract_id: &amp;str, chain: Chain) -&gt; Self {
        // Use an absolute path
        let wasm_path = &quot;../../target/wasm32-unknown-unknown/release/my-contract.wasm&quot;;
       // OR give the contract name and set the ARTIFACTS_DIR environment variable to the artifacts folder
       let wasm_path = &quot;my-contract&quot;;
        Self(
            Contract::new(contract_id, chain)
            // Adds the wasm path for uploading to a node
            .with_wasm_path(wasm_path)
            // Adds the contract's endpoint functions for mocking
            .with_mock(Box::new(
                   ContractWrapper::new_with_empty(
                     my_contract::contract::execute,
                     my_contract::contract::instantiate,
                     my_contract::contract::query,
                ))),
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Notice that we build the <code>Contract</code> instance and point it to the contract code using <code>with_wasm_path(...)</code>, where we provide the contract name <code>&quot;my-contract&quot;</code>.
This contract name will be used to search the artifacts directory (set by <code>ARTIFACTS_DIR</code> env variable) for a <code>my-contract.wasm</code> file.</p>
<p>Alternatively you can specify a path to the wasm artifact that's generated after running <code>RUSTFLAGS='-C link-arg=-s' cargo wasm</code> in the contract's directory. See the <a href="https://docs.cosmwasm.com/docs/1.0/getting-started/compile-contract/">CosmWasm documentation on compiling your contract</a> for more information.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Now you can start writing executable functions for your contracts with ensured type safety.
You can write functions that are generic or that can only be used called in a specific environment.
The environments that are currently supported are:</p>
<ol>
<li><a href="https://crates.io/crates/cw-multi-test">cw-multi-test</a></li>
<li>Blockchain daemons with CosmWasm enabled: <a href="https://github.com/CosmosContracts/juno">junod</a>, <a href="https://github.com/osmosis-labs/osmosis">osmosisd</a>,...</li>
</ol>
<h3 id="generic-function"><a class="header" href="#generic-function">Generic function</a></h3>
<p>Generic functions can be executed over any environment.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Chain: CwEnv&gt; MyContract&lt;Chain&gt; {
    pub fn deploy(&amp;self, instantiate_msg: &amp;InstantiateMsg) -&gt; Result&lt;()&gt; {
        let sender = &amp;self.get_chain().sender();
        self.upload()?;
        let resp = self.instantiate(instantiate_msg, Some(&amp;sender), None)?;
        let my_contract_address = resp.instantiated_contract_address()?;
        log::info!(&quot;deployed my-contract to {}&quot;, my_contract_address);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="daemon-only-functions"><a class="header" href="#daemon-only-functions">Daemon-only functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyContract&lt;Daemon&gt; {
    pub fn send_ibc_transaction(&amp;self, msg: &amp;ExecuteMsg) -&gt; Result&lt;String&gt; {
        let resp = self.execute(msg,None)?;
        let destination_port = resp.event_attr_value(&quot;ibc_transfer&quot;, &quot;destination_port&quot;)?;
        Ok(destination_port)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mock-only-functions"><a class="header" href="#mock-only-functions">Mock-only functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyContract&lt;Mock&gt; {
    pub fn call_other_chain (&amp;self, msg: &amp;ExecuteMsg) -&gt; Result&lt;String&gt; {
        let resp = self.execute(msg,None)?;
        let destination_port = resp.event_attr_value(&quot;ibc_transfer&quot;, &quot;destination_port&quot;)?;
        Ok(destination_port)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="endpoint-function-generation"><a class="header" href="#endpoint-function-generation">Endpoint function generation</a></h3>
<h4 id="execution"><a class="header" href="#execution">Execution</a></h4>
<p>We can expand on this functionality with a simple macro that provides access to a contract's endpoints as callable functions. This functionality is only available if you have access to the message structs's crate.</p>
<blockquote>
<p>You will want to feature-flag the function generation to prevent cw-orchestrator entering as a dependency when building your contract.</p>
</blockquote>
<p>Here's an example with the macro shielded behind a &quot;interface&quot; feature flag:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cw_serde]
#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::ExecuteFns))]
pub enum ExecuteMsg{
    Freeze {},
    UpdateAdmins { admins: Vec&lt;String&gt; },
    // Indicates that the call expects funds `Vec&lt;Coin&gt;`
    #[cfg_attr(feature = &quot;interface&quot;, payable)]
    Deposit {}
}

// If we now define a orchestrateable contract with this execute message
#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg)]
pub struct MyContract&lt;Chain&gt;;

// Then the message variants are available as functions on the struct through an &quot;ExecuteFns&quot; trait.
impl&lt;Chain: CwEnv + Clone&gt; MyContract&lt;Chain&gt; {
    pub fn test_macro(&amp;self) -&gt; Result&lt;(),CwOrchError&gt; {
        self.freeze()?;
        self.update_admins(vec![])?;
        self.deposit(&amp;[Coin::new(13,&quot;juno&quot;)])?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In order for the above code to work, you will need to follow those simple steps :</p>
<ol>
<li>
<p>Add the following line to your <code>packages/my-project.Cargo.toml</code>. This will allow to activate the interface feature for creating <code>ExecuteFns</code> outside of the crate</p>
<pre><code class="language-cargo">[features]
interface=[]
</code></pre>
</li>
<li>
<p>Add the following import in your <code>packages/interfaces/src/my-contract.rs</code> file :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use my_project::my_contract::ExecuteMsgFns;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h4 id="query"><a class="header" href="#query">Query</a></h4>
<p>Generating query functions is a similar process but has the added advantage of using the <code>cosmwasm-schema</code> return tags to detect the query's return type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cosmwasm_schema::cw_serde]
#[derive(QueryResponses)]
#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::QueryFns))]
pub enum QueryMsg {
    /// Returns [`InfoResponse`]
    #[returns(InfoResponse)]
    Info {},
}

#[cosmwasm_schema::cw_serde]
pub struct InfoResponse {
    pub admin: Addr,
}

// If we now define a orchestrateable contract with this execute message
#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg)]
pub struct MyContract&lt;Chain&gt;;

// Then the message variants are available as functions on the struct through an &quot;ExecuteFns&quot; trait.
impl&lt;Chain: CwEnv + Clone&gt; MyContract&lt;Chain&gt; {
    pub fn test_macro(&amp;self) -&gt; Result&lt;(),CwOrchError&gt; {
        // No need to specify returned type!
        // info of type `InfoResponse` is returned
        let info = self.info()?;
        let admin: Addr = info.admin;
        Ok(())
    }
}

<span class="boring">}</span></code></pre></pre>
<p>In order to derive query functions, you NEED to serive the QueryResponses crate for your QueryMsgs struct. This is mandatory in order to ensure type-safety for all messages and responses.</p>
<p>This time, add the following import in your <code>packages/interfaces/src/my-contract.rs</code> file :
<code>rust use my_project::my_contract::QueryMsgFns; </code></p>
<h4 id="refinement"><a class="header" href="#refinement">Refinement</a></h4>
<p>You can also refine your contract interface manually to add more complex interactions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// interfaces/src/my_contract.rs
// Import the cw-orchestrator traits
use cw_orch::interface::*;
// ...

impl&lt;Chain: CwEnv&gt; MyContract&lt;Chain&gt; {
    pub fn new(contract_id: &amp;str, chain: Chain) -&gt; Self {
      // ...
    }

    /// Query the balance of an address
    /// `address` - the address to query
    pub fn balance(&amp;self, address: Addr) -&gt; Result&lt;BalanceResponse&gt; {
        let balance_query = QueryMsg::Balance { address };
        self.query(balance_query)
    }

    /// Update the balance of an address
    /// `address` - the address to update
    /// `balance` - the new balance
    pub fn update_balance(&amp;self, address: Addr, balance: Uint128) -&gt; Result&lt;Chain::TxResult&gt; {
        let update_balance_msg = ExecuteMsg::UpdateBalance {
            address,
            balance,
        };
        self.execute(update_balance_msg)
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="learn-more"><a class="header" href="#learn-more">Learn more</a></h2>
<p>Got questions? Join the <a href="https://discord.gg/vAQVnz3tzj">Abstract Discord</a> and ask in the <code>#cw-orchestrator</code> channel.
Learn more about Abstract at <a href="https://abstract.money">abstract.money</a>.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://crates.io/crates/cw-orch">cw-orchestrator</a></li>
<li><a href="https://crates.io/crates/cw-plus-orc">cw-plus-orc</a></li>
<li><a href="https://crates.io/crates/abstract-cw-orch">Abstract Contract Interfaces</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>These variables are used by cw-orchestrator when interacting with a node using the <code>daemon</code> feature.</p>
<pre><code class="language-bash"># .env

# info, debug, trace
RUST_LOG=info

# where the contract wasms are located
ARTIFACTS_DIR=&quot;../artifacts&quot;

# where to store the state of your deployments
STATE_FILE=&quot;./daemon_state.json&quot;

# Mnemonics of the account that will be used to sign transactions
LOCAL_MNEMONIC=&quot;&quot;
TEST_MNEMONIC=&quot;&quot;
MAIN_MNEMONIC=&quot;&quot;
</code></pre>
<blockquote>
<p>IMPORTANT: Make sure to exclude the .env file in your gitignore.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-and-executing-scripts"><a class="header" href="#writing-and-executing-scripts">Writing and Executing Scripts</a></h1>
<p>Now that we have the interface written for our contract, we can start writing scripts to deploy and interact with it.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Like before, we're going to setup a new folder for our scripts. This time, we'll call it <code>scripts</code> and initialize it as a binary crate:</p>
<pre><code class="language-bash">cargo init --bin scripts
</code></pre>
<blockquote>
<p>If your cargo project is a workspace, be sure to add <code>scripts</code> to the [workspace].members array at the workspace root.</p>
</blockquote>
<p>Your scripts will have basically the same dependencies as your contract interfaces, but with a few additions:</p>
<pre><code class="language-bash">cargo add --path ../packages/interfaces
</code></pre>
<p>and also add the <code>dotenv</code> crate:</p>
<pre><code class="language-bash">cargo add anyhow dotenv log
</code></pre>
<p>and, we must enable the <code>daemon</code> feature on <code>cw_orch</code></p>
<pre><code class="language-bash">cargo add cw_orch --features daemon
</code></pre>
<h2 id="main-function"><a class="header" href="#main-function">Main Function</a></h2>
<p>Now that we have our dependencies setup, we can start writing our script. Either create a new file in the <code>src</code> directory of the <code>scripts/src</code> package, or use the <code>main.rs</code> file that was created by default.</p>
<p>This function is mostly just boilerplate, so you can copy and paste it into your new script file. It will just call your function and give you nicer error traces:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dotenv().ok();
    env_logger::init();

    use dotenv::dotenv;

    if let Err(ref err) = deploy_contract() {
        log::error!(&quot;{}&quot;, err);
        err.chain()
            .skip(1)
            .for_each(|cause| log::error!(&quot;because: {}&quot;, cause));

        // The backtrace is not always generated. Try to run this example
        // with `$env:RUST_BACKTRACE=1`.
        // log::debug!(&quot;backtrace: {:?}&quot;, err.backtrace());

        ::std::process::exit(1);
    }
}</code></pre></pre>
<h2 id="deployment-function"><a class="header" href="#deployment-function">Deployment Function</a></h2>
<p>First, we'll define a function that will deploy our contract to the chain. This function will setup the environment (connecting to the chain), deploy the contract, and return a <code>Result</code> with the contract address.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/src/my_contract.rs
use anyhow::Result;
use cw_orch::networks;
use cw_orch::{Addr, instantiate_daemon_env, NetworkInfo, DaemonOptionsBuilder};
// Traits for contract deployment
use cw_orch::interface::*;
use interfaces::my_contract::MyContract;

// Select the chain to deploy to
const NETWORK: NetworkInfo = networks::juno::UNI_6;
const CONTRACT_NAME: &amp;str = &quot;my-contract&quot;;

pub fn deploy_contract() -&gt; anyhow::Result&lt;Addr&gt; {
    // Create a runtime for the asynchronous actions
    let rt = Arc::new(tokio::runtime::Runtime::new().unwrap());

    // Specify the options for the blockchain daemon
    let options = DaemonOptionsBuilder::default()
        // or provide `chain_data`
        .network(NETWORK)
        .deployment_id(&quot;my_deployment_version&quot;)
        .build()?;

    // Setup the environment
    let (_sender, chain) = instantiate_daemon_env(&amp;rt, options)?;

    // Create a new instance of your contract interface
    let mut contract = MyContract::new(CONTRACT_NAME, chain);
    // Upload your contract
    contract.upload()?;

    // Instantiate your contract
    let init_msg = InstantiateMsg {
        // ...
    };
    // The second argument is the admin, the third is any coins to send with the init message
    contract.instantiate(&amp;init_msg, None, None)?;

    // Load and return the contract address
    let contract_addr = contract.address()?;
    Ok(contract_addr)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="additional-scripts"><a class="header" href="#additional-scripts">Additional Scripts</a></h3>
<p>So you have your contract deployed, but what now? You can write additional scripts to interact with your contract. For example, you can write a script to query the contract state, or to execute a contract method.</p>
<p>Here's an example of a script that queries the contract state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/src/my_contract.rs
// use ...
use my_contract::{QueryMsg};
// ...

pub fn query_contract() -&gt; anyhow::Result&lt;()&gt; {
    // Setup the environment
    let rt = Arc::new(tokio::runtime::Runtime::new().unwrap());
    let options = DaemonOptionsBuilder::default()
        .network(NETWORK)
        .build()?;
    let (_sender, chain) = instantiate_daemon_env(&amp;rt, options)?;

    // Create a new instance of your contract interface
    let contract = MyContract::new(CONTRACT_NAME, chain);
    // Load the contract address (this will use the address set from the previous deploy script)
    let contract_addr = contract.address();
    // Query the contract
    let res = contract.query(&amp;QueryMsg::Balance {
      address: contract_addr,
    })?;
    // Print the result
    println!(&quot;{:?}&quot;, res);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>And one that executes a contract method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/src/my_contract.rs
use cw_orch::*;
use my_contract::{ExecuteMsg, ExecuteMsgFnsDerive};
// ...

pub fn execute_contract() -&gt; anyhow::Result&lt;()&gt; {
    // Setup the environment
    let rt = Arc::new(tokio::runtime::Runtime::new().unwrap());
    let options = DaemonOptionsBuilder::default()
        .network(NETWORK)
        .build()?;
    let (_sender, chain) = instantiate_daemon_env(&amp;rt, options)?;

    // Create a new instance of your contract interface
    let contract = MyContract::new(CONTRACT_NAME, chain);
    // Load the contract address (this will use the address set from the previous deploy script)
    let contract_addr = contract.address();
    // Execute a contract method
    let res = contract.execute(&amp;ExecuteMsg::UpdateBalance {
      address: contract_addr,
      balance: Uint128::from(1000000u128),
    }, None)?;
    // OR, if you're usincg the `ExecuteMsgFnsDerive` derive macro
    let res = contract.update_balance(contract_addr, Uint128::from(1000000u128))?;
    // Print the result
    println!(&quot;{:?}&quot;, res);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h1>
<p>To get started writing integration tests with cw-orchestrator, first add <code>cw-orchestrator</code> to your dependencies.</p>
<pre><code class="language-bash">cargo add --dev cw-orch
</code></pre>
<p>The following assumes that you have written your interfaces as described in <a href="tutorial/./quick_start/interfaces.html">Interfaces</a>.</p>
<p>TODO: put mock example code here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration"><a class="header" href="#integration">Integration</a></h1>
<p>Now that you have your contract interfaces you can export a comprehensive deployment of your application that can easily be used by others.</p>
<p>The idea is simple. If you can provide an easy way for others to deploy your contracts/application to their environments, then you're making it extremely easy for them to use and build on your application.</p>
<p>As an example we will create a deployment for the <a href="https://abstract.money/">Abstract smart-contract framework</a>.</p>
<h2 id="the-deployment"><a class="header" href="#the-deployment">The deployment</a></h2>
<p>The deployment can be represented by a struct containing all the contracts that are uploaded and instantiated when the protocol is deployed.</p>
<pre><code class="language-rust ignore">// Our Abstract deployment
pub struct Abstract&lt;Chain: CwEnv&gt; {
    pub ans_host: AnsHost&lt;Chain&gt;,
    pub version_control: VersionControl&lt;Chain&gt;,
}</code></pre>
<h3 id="implementing-deploy"><a class="header" href="#implementing-deploy">Implementing <code>Deploy</code></a></h3>
<p>Now we can implement the <code>cw_orch::Deploy</code> trait for the <code>Abstract</code> struct.</p>
<pre><code class="language-rust ignore"><span class="boring">use cw_orch::prelude::*;
</span><span class="boring">use cw_orch::error::CwOrchError;
</span><span class="boring">use cw_multi_test::ContractWrapper;
</span><span class="boring">use abstract_interface::{AnsHost, VersionControl};
</span><span class="boring">pub struct Abstract&lt;Chain: CwEnv&gt; {
</span><span class="boring">  pub ans_host: AnsHost&lt;Chain&gt;,
</span><span class="boring">  pub version_control: VersionControl&lt;Chain&gt;,
</span><span class="boring">}
</span>
impl&lt;Chain: CwEnv&gt; cw_orch::Deploy&lt;Chain&gt; for Abstract&lt;Chain&gt; {
    // We don't have a custom error type
    type Error = CwOrchError;
    type DeployData = semver::Version;

    fn store_on(chain: Chain) -&gt; Result&lt;Self, Self::Error&gt; {
        // &quot;abstract&quot; is a reserved keyword in rust!
        let mut abstrct = Abstract::new(chain);

        // Upload the contracts to the chain
        abstrct.ans_host.upload()?;
        abstrct.version_control.upload()?;

        Ok(abstrct)
    }

    fn deploy_on(chain: Chain, version: semver::Version) -&gt; Result&lt;Self, CwOrchError&gt; {        
        // ########### Upload ##############
        let abstrct = Self::store_on(chain)?;

        // ########### Instantiate ##############
        abstrct.ans_host.instantiate(
            &amp;abstract_core::ans_host::InstantiateMsg {},
            Some(sender),
            None,
        )?;

        abstrct.version_control.instantiate(
            &amp;abstract_core::version_control::InstantiateMsg {},
            Some(sender),
            None,
        )?;

        // ... 

        Ok(abstrct)
    }

    fn load_from(chain: Chain) -&gt; Result&lt;Self, Self::Error&gt; {
        let abstrct = Self::new(chain);
        Ok(abstrct)
    }
}</code></pre>
<p>Now <code>Abstract</code> is an application that can be deployed to a mock and real environment with <strong>one</strong> line of code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_test(mock: Mock) -&gt; Result&lt;(), CwOrchError&gt; {
    let version = &quot;1.0.0&quot;.parse().unwrap();
    // Deploy abstract
    let abstract_ = Abstract::deploy_on(mock.clone(), version)?;
}
<span class="boring">}</span></code></pre></pre>
<p>And then when setting up your own deployment you can load these applications to access their contracts (for accessing configuration, addresses, ...)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Chain: CwEnv&gt; cw_orch::Deploy&lt;Chain&gt; for MyApplication&lt;Chain&gt; {
    /// ...
    fn deploy_on(chain: Chain, _data: Empty) -&gt; Result&lt;Self, CwOrchError&gt; {

        let abstract_: Abstract = Abstract::load_from(chain)?;

        /// ... do stuff with Abstract
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<ul>
<li><strong><a href="advanced/ci-cd.html">CI/CD</a></strong>
<ul>
<li>Deploying your contracts in using continuous integration and deployment tools.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration-and-deployment"><a class="header" href="#continuous-integration-and-deployment">Continuous Integration and Deployment</a></h1>
<p>One of the tools that can improve your developer productivity drastically is setting up pipelines for your contract deployments. </p>
<p>cw-orchestrator does not <em>currently</em> add additional support for actions, but an example using the directory structure specified in <a href="advanced/interfaces.html">interfaces</a> can be found below:</p>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
---
name: Deploy Contracts  
on:  
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_dispatch  
  workflow_dispatch:  
  push:  
    branches: [ 'mainline' ]  
    paths:  
      - 'contracts/src/**/*.rs'  
      - '.github/workflows/deploy.yml'  
  
env:
  VERSION_CONTROL_ADDRESS: juno16enwrxhdtsdk8mkkcaj37fgp37wz0r3err4hxfz52lcdyayexnxs4468mu  
  STATE_FILE: &quot;./daemon_state.json&quot;  
  ARTIFACTS_DIR: &quot;./target/wasm32-unknown-unknown/release&quot;  
  SCHEMA_DIR: &quot;./schema&quot;  
  
jobs:  
  deploy:  
    runs-on: ubuntu-latest  
    steps:  
      - uses: actions/checkout@v3  
      - uses: actions-rs/toolchain@v1  
        with:  
          toolchain: nightly  
          target: wasm32-unknown-unknown  
          override: true  
      - name: Run cargo wasm  
        uses: actions-rs/cargo@v1  
        with:  
          command: build  
          args: --package counter-app --release --target wasm32-unknown-unknown  
        env:  
          RUSTFLAGS: '-C link-arg=-s'  

      - name: Run deployment script  
        uses: actions-rs/cargo@v1  
        with:  
          command: run  
          args: --package scripts --bin deploy_app  
        env:  
          CHAIN: &quot;juno&quot;  
          DEPLOYMENT: &quot;debugging&quot;  
          NETWORK: &quot;local&quot;  
          RUST_LOG: info  
          ARTIFACTS_DIR: ${{ env.ARTIFACTS_DIR }}  
          STATE_FILE: ${{ env.STATE_FILE }}  
  
          VERSION_CONTROL_ADDRESS: ${{ env.VERSION_CONTROL_ADDRESS }}  
          TEST_MNEMONIC: ${{ secrets.TEST_MNEMONIC }}  

      - name: Upload deployment daemon state  
        uses: actions/upload-artifact@v2  
        with:  
          name: deployment.json  
          path: ${{ env.STATE_FILE }}  
      - name: Upload WASM  
        uses: actions/upload-artifact@v2  
        with:  
          # TODO: name env or from cargo  
          name: counter_app.wasm  
          path: ${{ env.ARTIFACTS_DIR }}/counter_app.wasm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-cw-orchestrator"><a class="header" href="#contributing-to-cw-orchestrator">Contributing to cw-orchestrator</a></h1>
<p>Thank you for considering to contribute to the cw-orchestrator project! We appreciate your support and welcome contributions to help improve this multi-environment CosmWasm smart-contract scripting library. This document provides guidelines and instructions on how to contribute to the project effectively.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="contributing.html#code-of-conduct">Code of Conduct</a></li>
<li><a href="contributing.html#getting-started">Getting Started</a></li>
<li><a href="contributing.html#how-to-contribute">How to Contribute</a>
<ul>
<li><a href="contributing.html#reporting-bugs">Reporting Bugs</a></li>
<li><a href="contributing.html#suggesting-enhancements">Suggesting Enhancements</a></li>
<li><a href="contributing.html#code-contributions">Code Contributions</a>
<ul>
<li><a href="contributing.html#pull-requests">Pull Requests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="contributing.html#style-guide">Style Guide</a></li>
<li><a href="contributing.html#community">Community</a></li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>By participating in this project, you are expected to uphold our <a href="CODE_OF_CONDUCT.html">Code of Conduct</a>. Please read the Code of Conduct to ensure that you follow the community guidelines and contribute positively to the project.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To get started with contributing to the cw-orchestrator project, you should first familiarize yourself with the repository structure and the codebase. Please read the project's <a href="https://github.com/AbstractSDK/cw-orchestrator/">README</a> to understand the purpose, features, and usage of the cw-orchestrator library as well as its <a href="https://orchestrator.abstract.money">documentation</a>.</p>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to Contribute</a></h2>
<p>There are multiple ways to contribute to the cw-orchestrator project, including reporting bugs, suggesting enhancements, and submitting code contributions.</p>
<h2 id="reporting-bugs"><a class="header" href="#reporting-bugs">Reporting Bugs</a></h2>
<p>If you encounter any bugs or issues while using the cw-orchestrator library, please report them by creating a new issue in the <a href="https://github.com/AbstractSDK/cw-orchestrator/issues">issue tracker</a>. When reporting a bug, please provide the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed description of the issue, including steps to reproduce it</li>
<li>Any relevant logs, error messages, or screenshots</li>
<li>Information about your environment, such as the OS, software versions, and hardware specifications</li>
</ul>
<h2 id="suggesting-enhancements"><a class="header" href="#suggesting-enhancements">Suggesting Enhancements</a></h2>
<p>We welcome suggestions for new features or improvements to the existing functionality of the cw-orchestrator library. To suggest an enhancement, create a new issue in the <a href="https://github.com/AbstractSDK/cw-orchestrator/issues">issue tracker</a> with the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed explanation of the proposed enhancement, including its benefits and potential use cases</li>
<li>If applicable, any examples or mockups of the proposed feature</li>
</ul>
<h2 id="code-contributions"><a class="header" href="#code-contributions">Code Contributions</a></h2>
<p>To contribute code to the cw-orchestrator project, please follow these steps:</p>
<ol>
<li>Fork the repository to your own GitHub account.</li>
<li>Clone your fork to your local machine.</li>
<li>Create a new branch for your changes using the <code>git checkout -b feature/your-feature-name</code> command.</li>
<li>Make your changes and commit them with a clear and concise commit message.</li>
<li>Push your branch to your fork on GitHub.</li>
<li>Create a new pull request against the main branch of the cw-orchestrator repository.</li>
</ol>
<h2 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h2>
<p>When submitting a pull request, please make sure that your code follows the <a href="contributing.html#style-guide">Style Guide</a> and that all tests pass. Please provide a detailed description of your changes, including the motivation for the changes and any potential impact on the project. This will help maintainers review your pull request more effectively.</p>
<h2 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h2>
<p>The cw-orchestrator project follows the Rust coding style and conventions. Please ensure that your code adheres to these guidelines to maintain consistency and readability throughout the codebase.</p>
<ul>
<li>Use proper indentation (4 spaces) and consistent formatting (<code>cargo fmt</code>).</li>
<li>Write descriptive variable and function names.</li>
<li>Use comments to explain complex or non-obvious code.</li>
<li>Follow the <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a> for API design.</li>
<li>Add documentation for public functions, types, and modules.</li>
<li>Write <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">doc tests</a>
for public functions and methods.</li>
</ul>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<p>To join the cw-orchestrator community, please join the <a href="https://discord.gg/uch3Tq3aym">Abstract Discord server</a> and the <code>#cw-orchestrator</code> channel. You can also follow the project on <a href="https://twitter.com/AbstractSDK">Twitter</a> and <a href="https://github.com/AbstractSDK">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-1"><a class="header" href="#references-1">References</a></h1>
<p>Easy, right? Try building your contracts with <a href="https://abstract.money">Abstract</a> for the same experience with smart contracts.
Get started <a href="https://docs.abstract.money/building-on-abstract/writing-modules/writing-an-app">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
